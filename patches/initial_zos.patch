diff --git a/src/definitions.h b/src/definitions.h
index 27777de..1a608c3 100644
--- a/src/definitions.h
+++ b/src/definitions.h
@@ -66,8 +66,12 @@
 #elif defined(HAVE_NCURSES_H)
 #include <ncurses.h>
 #else
+#if defined(__MVS__)
+#include <ncurses/ncurses.h>
+#else
 #include <curses.h>
 #endif
+#endif
 
 /* Native language support. */
 #ifdef ENABLE_NLS
@@ -589,6 +593,12 @@ typedef struct openfilestruct {
 #endif
 	bool modified;
 		/* Whether the file has been modified. */
+#ifdef __MVS__
+  int needs_conversion;
+  int is_dataset;
+  int reclen;
+  char * dsname;
+#endif
 #ifdef ENABLE_COLOR
 	syntaxtype *syntax;
 		/* The syntax that applies to this file, if any. */
diff --git a/src/files.c b/src/files.c
index fc30ad6..bf8ad59 100644
--- a/src/files.c
+++ b/src/files.c
@@ -30,6 +30,10 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/wait.h>
+#ifdef __MVS__
+#include <dio.h>
+char *safe_tempfileext(char* extension);
+#endif
 
 #define RW_FOR_ALL  (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)
 
@@ -398,6 +402,12 @@ bool open_buffer(const char *filename, bool new_one)
 	/* Display newlines in filenames as ^J. */
 	as_an_at = FALSE;
 
+#ifdef __MVS__
+    int isdataset = FALSE;
+    int reclen = -1;
+    char * dsname = NULL;
+#endif
+
 #ifdef ENABLE_OPERATINGDIR
 	if (outside_of_confinement(filename, FALSE)) {
 		statusline(ALERT, _("Can't read file from outside of %s"), operating_dir);
@@ -405,7 +415,53 @@ bool open_buffer(const char *filename, bool new_one)
 	}
 #endif
 
-	realname = real_dir_from_tilde(filename);
+#ifdef __MVS__
+    if (filename != NULL)
+    {
+      if (is_dataset(filename)) {
+        struct DFILE* dsfile = open_dataset(filename, NULL);
+        if (!dsfile) {
+	        statusline(ALERT, _("Could not open dataset for %s"), filename);
+          return FALSE;
+        }
+
+        if (dsfile->err) {
+	        statusline(ALERT, _(dsfile->msgbuff));
+          close_dataset(dsfile);
+          return FALSE;
+        }
+
+        if (read_dataset(dsfile) > 0) {
+	        statusline(ALERT, _(dsfile->msgbuff));
+          close_dataset(dsfile);
+          return FALSE;
+        }
+
+        // Store the original dataset name
+        dsname = strdup(filename);
+        reclen = dsfile->reclen;
+        isdataset = TRUE; 
+
+        // Create a temporary file to represent the dataset 
+        char file_suffix[PATH_MAX];
+        map_to_unixfile(dsfile, file_suffix);
+        realname = safe_tempfileext(file_suffix);
+
+        if (write_dataset_to_temp_file(dsfile, realname, dsfile->txtflag == 0 || dsfile->is_binary) != 0) {
+	        statusline(ALERT, _(dsfile->msgbuff));
+          close_dataset(dsfile);
+          return FALSE;
+        }
+        
+        if (close_dataset(dsfile) > 0) {
+	        statusline(ALERT, _(dsfile->msgbuff));
+          return FALSE;
+        }
+      } 
+    } 
+  if (!isdataset)
+#endif
+	  realname = real_dir_from_tilde(filename);
 
 	/* Don't try to open directories, character files, or block files. */
 	if (*filename != '\0' && stat(realname, &fileinfo) == 0) {
@@ -480,6 +536,16 @@ bool open_buffer(const char *filename, bool new_one)
 		openfile->current = openfile->filetop;
 		openfile->current_x = 0;
 		openfile->placewewant = 0;
+#ifdef __MVS__
+    if (isdataset) {
+      openfile->is_dataset = 1;
+      openfile->reclen = reclen;
+      openfile->dsname = dsname;
+    }
+    else {
+      openfile->is_dataset = 0;
+    }
+#endif
 	}
 
 #ifdef ENABLE_COLOR
@@ -907,6 +973,9 @@ int open_file(const char *filename, bool new_one, FILE **f)
 
 	/* Try opening the file. */
 	fd = open(full_filename, O_RDONLY);
+#ifdef __MVS__
+  openfile->needs_conversion =  __file_needs_conversion(fd);
+#endif
 
 #ifndef NANO_TINY
 	restore_handler_for_Ctrl_C();
@@ -1443,6 +1512,36 @@ char *check_writable_directory(const char *path)
 	return full_path;
 }
 
+#ifdef __MVS__
+char *safe_tempfileext(char* extension)
+{
+	const char *env_dir = getenv("TMPDIR");
+	char *tempdir = NULL, *tempfile_name = NULL;
+	int descriptor;
+
+	/* Get the absolute path for the first directory among $TMPDIR
+	 * and P_tmpdir that is writable, otherwise use /tmp/. */
+	if (env_dir != NULL)
+		tempdir = check_writable_directory(env_dir);
+
+	if (tempdir == NULL)
+		tempdir = check_writable_directory(P_tmpdir);
+
+	if (tempdir == NULL)
+		tempdir = copy_of("/tmp/");
+
+	tempfile_name = nrealloc(tempdir, strlen(tempdir) + 12 + strlen(extension));
+	strcat(tempfile_name, "nano.XXXXXX");
+	strcat(tempfile_name, extension);
+
+	int fd = mkstemps(tempfile_name, strlen(extension));
+  close(fd); // it will get recreated
+  unlink(tempfile_name);
+
+  return tempfile_name;
+}
+#endif
+
 /* Create, safely, a temporary file in the standard temp directory.
  * On success, return the malloc()ed filename, plus the corresponding
  * file stream opened in read-write mode.  On error, return NULL. */
@@ -1755,6 +1854,7 @@ bool make_backup_of(char *realname)
 bool write_file(const char *name, FILE *thefile, bool normal,
 		kind_of_writing_type method, bool annotate)
 {
+
 #ifndef NANO_TINY
 	bool is_existing_file;
 		/* Becomes TRUE when the file is non-temporary and exists. */
@@ -1801,6 +1901,20 @@ bool write_file(const char *name, FILE *thefile, bool normal,
 			goto cleanup_and_exit;
 	}
 
+  
+#ifdef __MVS__
+  if (!is_existing_file)
+    __tag_new_file(fileno(thefile));
+  else if (openfile->statinfo->st_tag.ft_ccsid == FT_UNTAGGED) {
+    if (openfile->needs_conversion) {
+      __chgfdccsid(fileno(thefile), 1047);
+    } else
+      __setfdccsid(fileno(thefile), 0);
+  }
+  else
+    __chgfdccsid(fileno(thefile), openfile->statinfo->st_tag.ft_ccsid);
+#endif
+
 	/* When prepending, first copy the existing file to a temporary file. */
 	if (method == PREPEND) {
 		FILE *source = NULL;
@@ -1859,6 +1973,23 @@ bool write_file(const char *name, FILE *thefile, bool normal,
 		descriptor = open(realname, O_WRONLY | O_CREAT | ((method == APPEND) ?
 					O_APPEND : (normal ? O_TRUNC : O_EXCL)), permissions);
 
+#ifdef __MVS__
+  if (!is_existing_file)
+    __tag_new_file(descriptor);
+  else if (openfile->statinfo->st_tag.ft_ccsid == FT_UNTAGGED) {
+    struct f_cnvrt cvtreq = {SETCVTON, 0, 1047};
+    if (openfile->needs_conversion) {
+      fcntl(descriptor, F_CONTROL_CVT, &cvtreq);
+    __setfdccsid(descriptor, 0);
+    } else
+      __setfdccsid(descriptor, 0);
+  }
+  else
+    __chgfdccsid(descriptor, openfile->statinfo->st_tag.ft_ccsid);
+#endif
+
+	/* When prepending, first copy the existing file to a temporary file. */
+
 #ifndef NANO_TINY
 		if (normal)
 			restore_handler_for_Ctrl_C();
@@ -1985,7 +2116,52 @@ bool write_file(const char *name, FILE *thefile, bool normal,
 
 	if (fclose(thefile) != 0) {
 		statusline(ALERT, _("Error writing %s: %s"), realname, strerror(errno));
+	  goto cleanup_and_exit;
+  }
+
+#ifdef __MVS__
+  fprintf(stderr, "TESTING...: %d", openfile->is_dataset);
+  if (openfile->is_dataset) {
+
+  fprintf(stderr, "TESTING2...");
+    // copy from temporary file back to dataset
+    struct DFILE *dsfile = open_dataset(openfile->dsname, NULL);
+    if (!dsfile) {
+			statusline(ALERT, _("Cannot open dataset %s: %s"), openfile->dsname, strerror(errno));
+			goto cleanup_and_exit;
+    }
+
+    if (dsfile->err) {
+			statusline(ALERT, _("Error %s"), dsfile->msgbuff);
+      close_dataset(dsfile);
+			goto cleanup_and_exit;
+    }
+
+    if (read_temp_file_to_buffer(realname, dsfile) == NULL) {
+			statusline(ALERT, _("Error %s"), dsfile->msgbuff);
+      close_dataset(dsfile);
+      goto cleanup_and_exit;
+    } 
+
+    if (write_dataset(dsfile)) {
+			statusline(ALERT, _("Error %s"), dsfile->msgbuff);
+      close_dataset(dsfile);
+			goto cleanup_and_exit;
+    }
+    if (close_dataset(dsfile)) {
+			statusline(ALERT, _("Error %s"), dsfile->msgbuff);
+			goto cleanup_and_exit;
+    }
+  }
+
+  if (openfile->needs_conversion) {
+    __setfdccsid(fileno(thefile), 0);
+  }
+
+#endif
+
 
+if (0) {
   cleanup_and_exit:
 #ifndef NANO_TINY
 		if (errno == ENOSPC && normal) {
diff --git a/src/nano.c b/src/nano.c
index 0ae71d8..6cda18c 100644
--- a/src/nano.c
+++ b/src/nano.c
@@ -873,7 +873,11 @@ bool scoop_stdin(void)
 							"type ^D or ^D^D to finish.\n"));
 
 	/* Open standard input. */
+        #if defined(__MVS__)
+	stream = fopen("/dev/fd0", "rb");
+        #else
 	stream = fopen("/dev/stdin", "rb");
+        #endif
 	if (stream == NULL) {
 		int errnumber = errno;
 
diff --git a/src/text.c b/src/text.c
index e6e01f3..fa03288 100644
--- a/src/text.c
+++ b/src/text.c
@@ -2139,10 +2139,13 @@ void treat(char *tempfile_name, char *theprogram, bool spelling)
 				statusline(AHEM, _("Buffer is empty"));
 			return;
 		}
-
+#if defined(__MVS__)
+                timestamp_sec = (long)fileinfo.st_mtime;
+#else
 		timestamp_sec = (long)fileinfo.st_mtim.tv_sec;
 		timestamp_nsec = (long)fileinfo.st_mtim.tv_nsec;
-	}
+#endif
+        }
 
 	/* The spell checker needs the screen, so exit from curses mode. */
 	if (spelling)
@@ -2191,8 +2194,13 @@ void treat(char *tempfile_name, char *theprogram, bool spelling)
 
 	/* When the temporary file wasn't touched, say so and leave. */
 	if (timestamp_sec > 0 && stat(tempfile_name, &fileinfo) == 0 &&
+#if defined(__MVS__)
+                                        (long)fileinfo.st_mtime == timestamp_sec) 
+#else
 					(long)fileinfo.st_mtim.tv_sec == timestamp_sec &&
-					(long)fileinfo.st_mtim.tv_nsec == timestamp_nsec) {
+					(long)fileinfo.st_mtim.tv_nsec == timestamp_nsec) 
+#endif
+        {
 		statusline(REMARK, _("Nothing changed"));
 		return;
 	}
diff --git a/syntax/Makefile.in b/syntax/Makefile.in
index 3705047..7f7a1ff 100644
--- a/syntax/Makefile.in
+++ b/syntax/Makefile.in
@@ -1927,6 +1927,7 @@ pkgdata_DATA = asm.nanorc \
 		changelog.nanorc \
 		cmake.nanorc \
 		c.nanorc \
+		cobol.nanorc \
 		css.nanorc \
 		default.nanorc \
 		elisp.nanorc \
diff --git a/syntax/cobol.nanorc b/syntax/cobol.nanorc
new file mode 100644
index 0000000..da13102
--- /dev/null
+++ b/syntax/cobol.nanorc
@@ -0,0 +1,37 @@
+## Syntax highlighting for COBOL files.
+
+syntax cobol "\.cob|\.cbl|\.cpy$"
+header "^       IDENTIFICATION DIVISION\."
+magic "^       PROGRAM-ID\."
+
+# Comments.
+color brightblue "^[[:blank:]]*\*.*$"
+
+# Divisions.
+color green "^       (IDENTIFICATION|ENVIRONMENT|DATA|PROCEDURE) DIVISION\."
+color green "^       CONFIGURATION SECTION\."
+
+# Sections.
+color green "^       (WORKING-STORAGE|LINKAGE|COMMUNICATION|REPORT|SCREEN) SECTION\."
+
+# Paragraphs and sentences.
+color brightmagenta "^[[:blank:]]*[A-Z][A-Z0-9-]*\."
+
+# Data types.
+color cyan "\<(PIC|PICTURE)\>"
+color cyan "\<(LEVEL|OCCURS)\>"
+
+# COBOL verbs.
+color brightyellow "\<(ACCEPT|ADD|ALTER|CALL|CANCEL|CLOSE|COMPUTE|CONTINUE|DELETE|DISPLAY|DIVIDE|ELSE|END|EVALUATE|EXEC|EXIT|GENERATE|GO|IF|INITIALIZE|INSPECT|MERGE|MOVE|MULTIPLY|OPEN|PERFORM|READ|RECEIVE|RELEASE|RETURN|REWRITE|SEARCH|SEND|SET|SORT|START|STOP|STRING|SUBTRACT|UNSTRING|WRITE)\>"
+
+# Special registers.
+color magenta "\<(ADDRESS|EOP|EOJ|EOF|EOL|EOC|EQ|GE|GT|LE|LT|NE|NOT|NULL|NULLS|OPTION|SPACE|SPACES|ZERO|ZEROS)\>"
+
+# Quoted strings.
+color brightred "'[^']*'|\"[^\"]*\""
+
+# Reminders.
+color brightwhite,yellow "\<(FIXME|TODO|XXX)\>"
+
+# Trailing whitespace.
+color red "[[:blank:]]+$"
